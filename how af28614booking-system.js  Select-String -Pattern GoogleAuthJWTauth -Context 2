// Booking System with Calendar Integration and Notifications
import { google } from 'googleapis';
import nodemailer from 'nodemailer';
import twilio from 'twilio';

class BookingSystem {
  constructor() {
    this.calendar = null;
    this.emailTransporter = null;
    this.smsClient = null;
    this.initializeServices();
  }

  async initializeServices() {
    try {
      // Initialize Google Calendar with OAuth2 (personal account)
      if (process.env.GOOGLE_CLIENT_EMAIL && process.env.GOOGLE_PRIVATE_KEY) {
        try {
          // For personal accounts, we'll use a simpler approach
          // Create calendar events without sending invitations
          const privateKey = process.env.GOOGLE_PRIVATE_KEY.replace(/\\n/g, '\n');
          if (!privateKey.includes('BEGIN PRIVATE KEY')) {
            throw new Error('Invalid private key format');
          }
          
          const auth = new google.auth.GoogleAuth({
            credentials: {
              type: 'service_account',
              client_email: process.env.GOOGLE_CLIENT_EMAIL,
              private_key: privateKey
            },
            scopes: [
              'https://www.googleapis.com/auth/calendar',
              'https://www.googleapis.com/auth/calendar.events'
            ]
          });
          this.calendar = google.calendar({ version: 'v3', auth });
          console.log('‚úÖ Google Calendar initialized with existing credentials');
        } catch (error) {
          console.log('‚ö†Ô∏è Google Calendar initialization failed:', error.message);
          this.calendar = null;
        }
      } else {
        console.log('‚ö†Ô∏è Google Calendar credentials not found - calendar integration disabled');
        this.calendar = null;
      }

      // Initialize Email Service
      if (process.env.EMAIL_SERVICE && process.env.EMAIL_USER && process.env.EMAIL_PASS) {
        try {
          this.emailTransporter = nodemailer.createTransport({
            service: process.env.EMAIL_SERVICE, // 'gmail', 'outlook', etc.
            auth: {
              user: process.env.EMAIL_USER,
              pass: process.env.EMAIL_PASS
            }
          });
          console.log('‚úÖ Email service initialized');
        } catch (error) {
          console.log('‚ö†Ô∏è Email service initialization failed:', error.message);
          this.emailTransporter = null;
        }
      } else {
        console.log('‚ö†Ô∏è Email credentials not found - email service disabled');
        this.emailTransporter = null;
      }

      // Initialize SMS Service
      if (process.env.TWILIO_ACCOUNT_SID && process.env.TWILIO_AUTH_TOKEN) {
        try {
          this.smsClient = twilio(process.env.TWILIO_ACCOUNT_SID, process.env.TWILIO_AUTH_TOKEN);
          console.log('‚úÖ SMS service initialized');
        } catch (error) {
          console.log('‚ö†Ô∏è SMS service initialization failed:', error.message);
          this.smsClient = null;
        }
      } else {
        console.log('‚ö†Ô∏è Twilio credentials not found - SMS service disabled');
        this.smsClient = null;
      }

      console.log('‚úÖ Booking system services initialized');
    } catch (error) {
      console.error('‚ùå Error initializing booking services:', error.message);
    }
  }

  async bookDemo(leadData, preferredTimes = [], smsPipeline = null) {
    try {
      console.log('[BOOKING SYSTEM] bookDemo called with:', { leadData, preferredTimes });
      
      const booking = {
        id: `demo_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        lead: leadData,
        status: 'pending',
        createdAt: new Date(),
        preferredTimes: preferredTimes,
        confirmedTime: null
      };

      // Try to book the first available time
      let bookedTime = null;
      console.log('[BOOKING SYSTEM] Checking availability for', preferredTimes.length, 'time slots');
      
      for (const timeSlot of preferredTimes) {
        console.log('[BOOKING SYSTEM] Checking slot:', timeSlot);
        const isAvailable = await this.isTimeSlotAvailable(timeSlot);
        console.log('[BOOKING SYSTEM] Slot available:', isAvailable);
        
        if (isAvailable) {
          bookedTime = timeSlot;
          console.log('[BOOKING SYSTEM] Selected slot:', bookedTime);
          break;
        }
      }

      if (bookedTime) {
        // Book the calendar event
        const calendarEvent = await this.createCalendarEvent(leadData, bookedTime);
        booking.confirmedTime = bookedTime;
        booking.calendarEventId = calendarEvent?.id || null;
        booking.status = 'confirmed';

        // Send notifications
        await this.sendBookingNotifications(booking);

        // Update SMS pipeline if provided
        if (smsPipeline && leadData.phoneNumber) {
          try {
            // Find and update the lead in SMS pipeline
            for (const [leadId, lead] of smsPipeline.pendingLeads.entries()) {
              if (lead.phoneNumber === leadData.phoneNumber && lead.status === 'email_received') {
                lead.status = 'demo_booked';
                lead.bookingId = booking.id;
                lead.bookedAt = new Date();
                console.log(`‚úÖ Updated lead ${leadId} status to demo_booked`);
                break;
              }
            }
          } catch (error) {
            console.error('‚ùå Error updating SMS pipeline:', error.message);
          }
        }

        const calendarMessage = calendarEvent ? 'Calendar event created and ' : 'Calendar not configured, but ';
        return {
          success: true,
          booking: booking,
          message: `${calendarMessage}demo booked for ${bookedTime.startTime} on ${bookedTime.date}`
        };
      } else {
        // No available slots, send follow-up email
        await this.sendFollowUpEmail(leadData, preferredTimes);
        
        return {
          success: false,
          booking: booking,
          message: 'No available slots, follow-up email sent'
        };
      }

    } catch (error) {
      console.error('‚ùå Error booking demo:', error.message);
      return {
        success: false,
        error: error.message
      };
    }
  }

  async createCalendarEvent(leadData, timeSlot) {
    if (!this.calendar) {
      console.log('üìÖ Google Calendar not configured - skipping calendar event creation');
      return null; // Return null instead of throwing error
    }

    try {
      const event = {
        summary: `Demo Call - ${leadData.businessName}`,
        description: `
Demo Call Details:
- Business: ${leadData.businessName}
- Contact: ${leadData.decisionMaker}
- Phone: ${leadData.phoneNumber}
- Email: ${leadData.email}
- Industry: ${leadData.industry}
- Location: ${leadData.location}

Notes: Cold call lead - interested in AI booking service
        `,
        start: {
          dateTime: timeSlot.startDateTime,
          timeZone: 'Europe/London'
        },
        end: {
          dateTime: timeSlot.endDateTime,
          timeZone: 'Europe/London'
        },
        // Removed attendees to avoid Domain-Wide Delegation requirement
        // We'll send email invitations separately
        reminders: {
          useDefault: false,
          overrides: [
            { method: 'email', minutes: 60 },
            { method: 'popup', minutes: 15 }
          ]
        }
      };

      // Use your existing calendar ID from environment variable
      const calendarId = process.env.GOOGLE_CALENDAR_ID || 'primary';
      
      const response = await this.calendar.events.insert({
        calendarId: calendarId,
        resource: event
      });

      console.log('‚úÖ Calendar event created successfully:', response.data.id);
      return response.data;

    } catch (error) {
      console.error('‚ùå Error creating calendar event:', error.message);
      
      // If it's a delegation error, try without attendees
      if (error.message.includes('Domain-Wide Delegation') || error.message.includes('attendees')) {
        console.log('üîÑ Retrying calendar event creation without attendees...');
        try {
          const eventWithoutAttendees = {
            summary: `Demo Call - ${leadData.businessN